import { Vec3Like } from "./vector";

export interface QuaternionLike {
  x: number;
  y: number;
  z: number;
  w: number;
}

export interface QuatSingleton {
  create(x?: number, y?: number, z?: number, w?: number): QuaternionLike;
  copy(q: QuaternionLike): QuatSingleton;
  store(q: QuaternionLike): QuatSingleton;
  /**Generated by ChatGPT then modified to fit API style
   * Calculates this quaternion from radian based euler angles
   */
  fromEuler(euler: Vec3Like): QuatSingleton;
  mul(q: QuaternionLike): QuatSingleton;
}

export const quat = {
  q: { x: 0, y: 0, z: 0, w: 0 },

  create(x = 0, y = 0, z = 0, w = 0): QuaternionLike {
    return { x, y, z, w };
  },
  copy(q: QuaternionLike): QuatSingleton {
    quat.q.x = q.x;
    quat.q.y = q.y;
    quat.q.z = q.z;
    quat.q.w = q.w;
    return quat;
  },
  store(q: QuaternionLike): QuatSingleton {
    q.x = quat.q.x;
    q.y = quat.q.y;
    q.z = quat.q.z;
    q.w = quat.q.w;
    return quat;
  },
  /**Generated by ChatGPT then modified to fit API style
   * Calculates this quaternion from radian based euler angles
   */
  fromEuler(euler: Vec3Like): QuatSingleton {
    const { x, y, z } = euler;
    const q = quat.q;

    // Convert the euler angles to quaternions
    q.x = Math.sin(x / 2) * Math.cos(y / 2) * Math.cos(z / 2) - Math.cos(x / 2) * Math.sin(y / 2) * Math.sin(z / 2);
    q.y = Math.cos(x / 2) * Math.sin(y / 2) * Math.cos(z / 2) + Math.sin(x / 2) * Math.cos(y / 2) * Math.sin(z / 2);
    q.z = Math.cos(x / 2) * Math.cos(y / 2) * Math.sin(z / 2) - Math.sin(x / 2) * Math.sin(y / 2) * Math.cos(z / 2);
    q.w = Math.cos(x / 2) * Math.cos(y / 2) * Math.cos(z / 2) + Math.sin(x / 2) * Math.sin(y / 2) * Math.sin(z / 2);

    return quat;
  },
  mul(q: QuaternionLike): QuatSingleton {
    let a = quat.q;
    let b = q;
    let out = quat.q;
    
    let ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
    let bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

    out.x = ax * bw + aw * bx + ay * bz - az * by;
    out.y = ay * bw + aw * by + az * bx - ax * bz;
    out.z = az * bw + aw * bz + ax * by - ay * bx;
    out.w = aw * bw - ax * bx - ay * by - az * bz;

    return quat;
  }

};
